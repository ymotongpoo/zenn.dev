---
title: "Rustã®å‹‰å¼· 6æ—¥ç›®"
emoji: "ðŸ¦€"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["rust", "exercise"]
published: true
published_at: 2022-10-02 22:00
---

## The Rust Programming Language æ—¥æœ¬èªžç‰ˆ ç¬¬6ç« 

åˆ—æŒ™åž‹ã¨ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒžãƒƒãƒã«ã¤ã„ã¦

### 6.1 Enumã‚’å®šç¾©ã™ã‚‹

* åˆ—æŒ™åž‹ã¯ `enum` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã§å®£è¨€ã™ã‚‹
* åˆ—æŒ™åž‹ã®åˆ—æŒ™å­ã¯ `åž‹å::å€¤å` ã§è¨˜è¿°ã™ã‚‹

```rust
enum IpAddrKind {
    V4,
    V6,
}

let four = IpAddrKind::V4;
```

* åˆ—æŒ™å­ã«ã¯ç›´æŽ¥ãƒ‡ãƒ¼ã‚¿ã‚’æ ¼ç´ã™ã‚‹ã“ã¨ã‚‚å¯èƒ½ã€‚å„åˆ—æŒ™å­ã§ç•°ãªã‚‹ãƒ‡ãƒ¼ã‚¿åž‹ã‚’æ ¼ç´ã—ã¦ã‚‚è‰¯ã„ã€‚

```rust
enum IpAddrKind {
    V4(String),
    V6(String),
}

let four = IpAddrKind(String::from("127.0.0.1"));
```

* Enumã‚‚ãƒ¡ã‚½ãƒƒãƒ‰ãŒæŒã¦ã¦æ§‹é€ ä½“ã¨åŒæ§˜ã« `impl` ã§å®Ÿè£…ã™ã‚‹
* Enumã¯ç›´å’Œåž‹ã‚’å®Ÿç¾ã™ã‚‹ç”¨é€”ã¨ã—ã¦ä½¿ã‚ã‚Œã¦ã„ã‚‹
  * `Option` åž‹ã¯ãƒ—ãƒ¬ãƒªãƒ¥ãƒ¼ãƒ‰ã«ã™ã‚‰æŽ¡ç”¨ã•ã‚Œã¦ã„ã‚‹
  * `Option` åž‹ã‹ã‚‰å€¤ã‚’å–ã‚Šå‡ºã™ãŸã‚ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒ[ãŸãã•ã‚“ç”¨æ„](https://doc.rust-lang.org/std/option/enum.Option.html)ã•ã‚Œã¦ã„ã‚‹

### 6.2 matchåˆ¶å¾¡ãƒ•ãƒ­ãƒ¼æ¼”ç®—å­

* Enumåž‹ã®åˆ—æŒ™å­ã«å¿œã˜ã¦å‡¦ç†ã‚’ã™ã‚‹å ´åˆã«matchãŒä½¿ãˆã‚‹
* åˆ—æŒ™å­ãŒå€¤ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã«ã¯ã€å¤‰æ•°ã‚’ãƒ‘ã‚¿ãƒ¼ãƒ³ã«è¿½åŠ ã™ã‚‹
  * ã“ã‚Œã‚‚ OCaml ã¨ã‹ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒžãƒƒãƒã«ä¼¼ã¦ã‚‹

```rust
enum Coin{
    Penny,
    Nickel,
    Dime,
    Quater(UsState),
}

fn value_in_cents(coin: Coin) -> u32 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => { // state ã§ UsState ã®å€¤ã‚’ä¿æŒ
            println!("State quarter from {:?}!", state);
            25
        },
    }
}
```

* Enumåž‹ã‚’matchã™ã‚‹ã¨ãã¯ã™ã¹ã¦ã®åˆ—æŒ™å­ã«é–¢ã—ã¦ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ›¸ã‹ãªã„ã¨ã„ã‘ãªã„
  * ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã« `_` ã¨ã„ã†ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãŒä½¿ãˆã‚‹ã€‚ï¼ˆã“ã‚Œã‚‚ OCaml ã«ä¼¼ã¦ã‚‹ï¼‰

### 6.3 if letã§ç°¡æ½”ãªåˆ¶å¾¡ãƒ•ãƒ­ãƒ¼

* `if let` ã¯ç‰¹å®šã®ã‚±ãƒ¼ã‚¹ã ã‘å‡¦ç†ã—ãŸã„å ´åˆã® `match` ã®ç³–è¡£æ§‹æ–‡ã®ã‚ˆã†ãªã‚‚ã®

```rust
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}", state);
} else {
    count += 1
}
```

## Rustlings

enums ã®ä¸€éƒ¨ãŒãã‚Œã£ã½ã„ã®ã§ã‚„ã£ã¦ã¿ã‚‹

### enums1.rs

`main` ã®ä¸­ã§ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã¦ã„ã‚‹åž‹ã‚’å®šç¾©ã—ã¦çµ‚ã‚ã‚Š

```rust
#[derive(Debug)]
enum Message {
    Quit,
    Echo,
    Move,
    ChangeColor,
}

fn main() {
    println!("{:?}", Message::Quit);
    println!("{:?}", Message::Echo);
    println!("{:?}", Message::Move);
    println!("{:?}", Message::ChangeColor);
}
```

### enums2.rs

ã‚„ã¯ã‚Š `enums1.rs` ã¨åŒæ§˜ã«ã€ `main` ã® `messages` å†…ã§å‘¼ã°ã‚Œã¦ã„ã‚‹ã‚ˆã†ãªå€¤ã‚’æŒã¤ã‚ˆã†ã« `Message` ã®å®šç¾©ã‚’åŸ‹ã‚ãŸã ã‘ã€‚

```rust
#[derive(Debug)]
enum Message {
    Move { x: i32, y: i32 },
    Echo(String),
    ChangeColor(i32, i32, i32),
    Quit,
}

impl Message {
    fn call(&self) {
        println!("{:?}", &self);
    }
}

fn main() {
    let messages = [
        Message::Move { x: 10, y: 30 },
        Message::Echo(String::from("hello world")),
        Message::ChangeColor(200, 255, 255),
        Message::Quit,
    ];

    for message in &messages {
        message.call();
    }
}
```

### enums3.rs

ãƒ†ã‚¹ãƒˆã§ç”¨æ„ã•ã‚Œã¦ã„ãŸå‡¦ç†ã¨ `State` ã®å®šç¾©ã‚’ã‚‚ã¨ã« `Message` ã®åˆ—æŒ™å­ã®å€¤ã®åž‹ã‚’åˆã‚ã›ãŸã‚‰çµ‚ã‚ã£ãŸã€‚

```rust
enum Message {
    ChangeColor((u8, u8, u8)),
    Echo(String),
    Move(Point),
    Quit,
}

struct Point {
    x: u8,
    y: u8,
}

struct State {
    color: (u8, u8, u8),
    position: Point,
    quit: bool,
}

impl State {
    fn change_color(&mut self, color: (u8, u8, u8)) {
        self.color = color;
    }

    fn quit(&mut self) {
        self.quit = true;
    }

    fn echo(&self, s: String) {
        println!("{}", s);
    }

    fn move_position(&mut self, p: Point) {
        self.position = p;
    }

    fn process(&mut self, message: Message) {
        match message {
            Message::ChangeColor(c) => self.change_color(c),
            Message::Echo(s) => self.echo(s),
            Message::Move(p) => self.move_position(p),
            Message::Quit => self.quit(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_match_message_call() {
        let mut state = State {
            quit: false,
            position: Point { x: 0, y: 0 },
            color: (0, 0, 0),
        };
        state.process(Message::ChangeColor((255, 0, 255)));
        state.process(Message::Echo(String::from("hello world")));
        state.process(Message::Move(Point { x: 10, y: 15 }));
        state.process(Message::Quit);

        assert_eq!(state.color, (255, 0, 255));
        assert_eq!(state.position.x, 10);
        assert_eq!(state.position.y, 15);
        assert_eq!(state.quit, true);
    }
}
```
