---
title: "Rustã®å‹‰å¼· 8æ—¥ç›®"
emoji: "ğŸ¦€"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["rust", "exercise"]
published: true
---

## The Rust Programming Language æ—¥æœ¬èªç‰ˆ ç¬¬8ç« 

ã„ã‚ˆã„ã‚ˆã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å‹ã«ã¤ã„ã¦ã®ç« ã€‚æ¥½ã—ã¿ã€‚

### 8.1 ãƒ™ã‚¯ã‚¿ã§å€¤ã®ãƒªã‚¹ãƒˆã‚’ä¿æŒã™ã‚‹

* ãƒ™ã‚¯ã‚¿å‹ `Vec<T>` ã¯è¦ç´ ã®ãƒªã‚¹ãƒˆãŒã‚ã‚‹å ´åˆã«ä¾¿åˆ©
* `vec!` ãƒã‚¯ãƒ­ã§åˆæœŸåŒ–ã™ã‚‹ã¨åŒæ™‚ã«ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã®å‹ã‚’æ¨è«–ã§ãã‚‹ï¼ˆ `let v = vec![1, 2, 3];` ï¼‰
* ãƒ™ã‚¯ã‚¿ã¸ã®è¦ç´ ã®è¿½åŠ ã¯ `push` ãƒ¡ã‚½ãƒƒãƒ‰
* ãƒ™ã‚¯ã‚¿ã¯ `drop` ã•ã‚Œã‚‹ã¨å…¨è¦ç´ ãŒ `drop` ã•ã‚Œã‚‹ã¨å…¨è¦ç´ ãŒ
* ãƒ™ã‚¯ã‚¿ã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã«ã¯ã‚«ã‚®ã‚«ãƒƒã‚³ã‹ `get` ãƒ¡ã‚½ãƒƒãƒ‰ã«æ·»ãˆå­—ã‚’æ¸¡ã™
  * `get` ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯è¦ç´ ãŒãªã‹ã£ãŸå ´åˆã«ã¯ `None` ã‚’è¿”ã™ã€‚ã‚«ã‚®ã‚«ãƒƒã‚³ã®å ´åˆã¯ãƒ‘ãƒ‹ãƒƒã‚¯ã™ã‚‹ã€‚ï¼ˆPythonã¨ã‹ã¨åŒã˜ï¼‰
* `for` ãƒ«ãƒ¼ãƒ—ã§å…¨è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å ´åˆã«ã¯å‚ç…§ã‚’å–å¾—ã™ã‚‹å¿…è¦ãŒã‚ã‚‹

### 8.2 æ–‡å­—åˆ—ã§UTF-8ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿æŒã™ã‚‹

* æ–‡å­—åˆ—å‹ã¯ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã«ã¯ `str` ã—ã‹å­˜åœ¨ã—ãªã„ã€‚ãã®å€Ÿç”¨ã® `&str` ã‚’è¦‹ã‚‹ã“ã¨ãŒå¤šã„ã€‚
* æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚ã‚‹ `String` ã¯ä¼¸é•·å¯èƒ½ã€ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã€æ‰€æœ‰æ¨©ã®ã‚ã‚‹UTF-8ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸæ–‡å­—åˆ—ã€‚
* `String::from()` ã¨ `to_string` ã¯åŒã˜
* `String` ã«ã¯ `push_str` ã¨ `push` ã¨ã„ã†ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã€å‰è€…ã¯ `str` ã‚’ã€å¾Œè€…ã¯æ–‡å­—ã‚’å—ã‘å–ã£ã¦ã€ `String` ã«è¿½åŠ ã™ã‚‹ã€‚ã“ã®ã¨ãæ¸¡ã—ã¦ã„ã‚‹å¤‰æ•°ã®æ‰€æœ‰æ¨©ã¯å–ã‚‰ãªã„ã€‚
* `String` ã®çµåˆã¯ãµã‚‹ã¾ã„ã¨ã—ã¦ã¯ã¾ã‚Šãã†ã€‚ `+` æ¼”ç®—å­ã®å·¦è¾ºã¯æ‰€æœ‰æ¨©ãŒå–ã‚‰ã‚Œã‚‹ã®ã«å¯¾ã—ã€å³è¾ºã¯å‚ç…§ã‚’æ¸¡ã™ã ã‘ãªã®ã§æ‰€æœ‰æ¨©ãŒå–ã‚‰ã‚Œãªã„ã€‚
  * ã“ã®ã¨ãå‹å¼·åˆ¶ã¨ã„ã†ã®ãŒåƒã„ã¦ã€ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¯ `String + &str` ã®æ‰±ã„ã«ãªã‚‹

```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // s1ã¯ãƒ ãƒ¼ãƒ–ã•ã‚Œã€ã‚‚ã†ä½¿ç”¨ã§ããªã„ã“ã¨ã«æ³¨æ„
```

* `format!` ãƒã‚¯ãƒ­ã¯ Go ã§è¨€ã†ã¨ã“ã‚ã® `fmt.Sprintf`
* `String` ã¯æ·»å­—ã§ãã®å ´æ‰€ã®ãƒã‚¤ãƒˆã®å€¤ã‚’è¿”ã™ã“ã¨ã¯ã—ãªã„
  * ã—ã‹ã—ç¯„å›²ã‚’ä½¿ã£ã¦éƒ¨åˆ†æ–‡å­—åˆ—ã«ã‚¢ã‚¯ã‚»ã‚¹ã¯ã§ãã‚‹ã€‚ï¼ˆ `let s = &hello[0..4];` ï¼‰
  * `chars()` ã‚„ `bytes()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ãˆã‚‹
  * `chars()` ã¯æ›¸ç´€ç´ ã‚¯ãƒ©ã‚¹ã‚¿ã‚’è¿”ã™ã‚ã‘ã§ã¯ãªã„ã®ã§æ–‡å­—ã¨ã—ã¦ã¿ãŸã‚‰ãŠã‹ã—ãªå€¤ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œãªã„
  * Goã§ã‚‚æ›¸ç´€ç´ ã‚¯ãƒ©ã‚¹ã‚¿ã¯ä¸Šæ‰‹ãæ‰±ãˆãªã„ï¼ˆc.f. <https://go.dev/play/p/m0mMaWNx1wS>ï¼‰

### 8.3 ã‚­ãƒ¼ã¨ãã‚Œã«ç´ã¥ã„ãŸå€¤ã‚’ãƒãƒƒã‚·ãƒ¥ãƒãƒƒãƒ—ã«æ ¼ç´ã™ã‚‹

* `HashMap<K, V>` ã¯ã‚­ãƒ¼ã¨å€¤ã®ãƒšã‚¢ã‚’æŒã¤ã€ä»–ã®è¨€èªã§ã‚‚è¾æ›¸ã‚„ãƒãƒƒãƒ—ãªã©ã¨å‘¼ã°ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿å‹
* `std::collections::HashMap::new` ã§ä½œã‚Œã‚‹
  * `insert` ãƒ¡ã‚½ãƒƒãƒ‰ã§è¦ç´ ã‚’ä¸Šæ›¸ãè¿½åŠ 
  * `entry` ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰ `or_insert` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã†ã¨è¦ç´ ãŒå­˜åœ¨ã—ãªã‹ã£ãŸã¨ãã ã‘è¿½åŠ ã™ã‚‹
* ãƒãƒƒã‚·ãƒ¥ãƒãƒƒãƒ—ã«ã‚­ãƒ¼ã‚„å€¤ã¨ã—ã¦ãƒ’ãƒ¼ãƒ—ã«å€¤ã‚’ä¿æŒã™ã‚‹å¤‰æ•°ã‚’æ¸¡ã™ã¨æ‰€æœ‰æ¨©ãŒç§»ã‚‹ã®ã§æ³¨æ„

## Rustlings

vecsã€stringsã€hashmaps ãŒå¯¾å¿œã—ã¦ã„ã‚‹ç« ãªã®ã§å›ç­”ã—ã¦ã„ãã€‚

### vecs1.rs

ãƒ†ã‚¹ãƒˆã®ä¸­èº«ãŒãƒ™ã‚¯ã‚¿ã®ä¸­èº«ã®é…åˆ—ã‚’å–ã£ã¦æ¯”è¼ƒã—ã¦ã„ãŸã®ã§ã€åŒã˜å€¤ã‚’æŒã¤ã‚ˆã†ãªãƒ™ã‚¯ã‚¿ã‚’ `vec!` ãƒã‚¯ãƒ­ã§ç”Ÿæˆ

```rust
fn array_and_vec() -> ([i32; 4], Vec<i32>) {
    let a = [10, 20, 30, 40]; // a plain array
    let v = vec![10, 20, 30, 40];

    (a, v)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_array_and_vec_similarity() {
        let (a, v) = array_and_vec();
        assert_eq!(a, v[..]);
    }
}
```

### vecs2.rs

`iter_mut` ãŒä½•ã‚’è¿”ã™ã‹è‰¯ãã‚ã‹ã‚‰ãªã‹ã£ãŸã®ã§[ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut)ã‚’å‚ç…§ã—ãŸã€‚ãã—ãŸã‚‰ `IterMut` æ§‹é€ ä½“ã‚’è¿”ã™ã£ã½ã„ã‘ã©ã€ãªãœã“ã‚ŒãŒ `for` ã§ `&mut` ã‚’è¿”ã—ã¦ãã‚‹ã®ã‹è‰¯ãã‚ã‹ã‚‰ãªã‹ã£ãŸã®ã§ã€é›°å›²æ°—ã§ `AsRef` ãƒˆãƒ¬ã‚¤ãƒˆãŒãã®è¾ºã‚ˆã—ãªã«ã‚„ã£ã¦ã‚‹ã¨äºˆæƒ³ã—ã¦é›°å›²æ°—ã§æ›¸ã„ãŸã‚‰åˆã£ã¦ãŸã€‚

```rust
fn vec_loop(mut v: Vec<i32>) -> Vec<i32> {
    for i in v.iter_mut() {
        *i *= 2;
    }
    v
}

fn vec_map(v: &Vec<i32>) -> Vec<i32> {
    v.iter().map(|num| num * 2).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vec_loop() {
        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_loop(v.clone());

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());
    }

    #[test]
    fn test_vec_map() {
        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_map(&v);

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());
    }
}
```

### strings1.rs

`current_favorite_color` ãŒ `str` ã‚’è¿”ã—ã¦ãŸã®ã§ `String` ã‚’è¿”ã™ã‚ˆã†ã«ä¿®æ­£ã—ãŸ

```rust
fn main() {
    let answer = current_favorite_color();
    println!("My current favorite color is {}", answer);
}

fn current_favorite_color() -> String {
    String::from("blue")
}
```

### strings2.rs

`&str` ã‚’æ¸¡ã™ã¨ã“ã‚ã« `String` ã‚’æ¸¡ã—ã¦ãŸã®ã‚’å‚ç…§ã«ã™ã‚‹ã“ã¨ã§å‹å¼·åˆ¶ã«ã‚ˆã£ã¦ `&str` ã«ã•ã›ãŸ

```rust
fn main() {
    let word = String::from("green"); // Try not changing this line :)
    if is_a_color_word(&word) {
        println!("That is a color word I know!");
    } else {
        println!("That is not a color word I know.");
    }
}

fn is_a_color_word(attempt: &str) -> bool {
    attempt == "green" || attempt == "blue" || attempt == "red"
}
```

### strings3.rs

`std::str::String::trim` ç›¸å½“ã®ã‚‚ã®ã‚’è‡ªåŠ›ã§å®Ÿè£…ã—ã‚ˆã†ã¨ã—ã¦ã„ã¦ã¯ã¾ã£ã¦ã„ãŸã€‚

```rust
fn trim_me(input: &str) -> String {
    let s = String::from(input);
    String::from(s.trim())
}

fn compose_me(input: &str) -> String {
    String::from(input) + " world!"
}

fn replace_me(input: &str) -> String {
    // TODO: Replace "cars" in the string with "balloons"!
    String::from(input).replace("cars", "balloons")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn trim_a_string() {
        assert_eq!(trim_me("Hello!     "), "Hello!");
        assert_eq!(trim_me("  What's up!"), "What's up!");
        assert_eq!(trim_me("   Hola!  "), "Hola!");
    }

    #[test]
    fn compose_a_string() {
        assert_eq!(compose_me("Hello"), "Hello world!");
        assert_eq!(compose_me("Goodbye"), "Goodbye world!");
    }

    #[test]
    fn replace_a_string() {
        assert_eq!(
            replace_me("I think cars are cool"),
            "I think balloons are cool"
        );
        assert_eq!(
            replace_me("I love to look at cars"),
            "I love to look at balloons"
        );
    }
}
```

### strings4.rs

æ¦‚ã­ã©ã®æ“ä½œãŒ `&str` ã¨ `String` ã®ã©ã¡ã‚‰ã‚’è¿”ã™ã‹ãªã‚“ã¨ãªãæƒ³åƒã§ããŸãŒã€å…¨éƒ¨ã‚’æŠŠæ¡ã™ã‚‹ã«ã¯ã¾ã ä¿®æ¥­ãŒå¿…è¦ã€‚

```rust
fn string_slice(arg: &str) {
    println!("{}", arg);
}
fn string(arg: String) {
    println!("{}", arg);
}

fn main() {
    string_slice("blue");
    string("red".to_string());
    string(String::from("hi"));
    string("rust is fun!".to_owned());
    string_slice("nice weather".into());
    string(format!("Interpolation {}", "Station"));
    string_slice(&String::from("abc")[0..1]);
    string_slice("  hello there ".trim());
    string("Happy Monday!".to_string().replace("Mon", "Tues"));
    string("mY sHiFt KeY iS sTiCkY".to_lowercase());
}
```

### hashmaps1.rs

ãƒãƒƒã‚·ãƒ¥ãƒãƒƒãƒ—ã®æ–°è¦ä½œæˆã®ã¨ãã«å‹ã®æŒ‡å®šã®å¿…è¦ãŒãªã„ã®ã‹ã¨ä¸€ç¬æˆ¸æƒ‘ã£ã¦ã—ã¾ã£ãŸ

```rust
use std::collections::HashMap;

fn fruit_basket() -> HashMap<String, u32> {
    let mut basket = HashMap::new();
    // Two bananas are already given for you :)
    basket.insert(String::from("banana"), 2);
    basket.insert(String::from("lemon"), 3);
    basket.insert(String::from("apple"), 5);
    basket
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn at_least_three_types_of_fruits() {
        let basket = fruit_basket();
        assert!(basket.len() >= 3);
    }

    #[test]
    fn at_least_five_fruits() {
        let basket = fruit_basket();
        assert!(basket.values().sum::<u32>() >= 5);
    }
}
```

### hashmaps2.rs

ãƒãƒƒã‚·ãƒ¥ãƒãƒƒãƒ—ã®ä¸­ã«ã‚­ãƒ¼ãŒå­˜åœ¨ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«ã¯ `entry` ã‚’ä½¿ã†ã¨ã„ã†ã®ã‚’å¿˜ã‚Œãªã„ã‚ˆã†ã«

```rust
use std::collections::HashMap;

#[derive(Hash, PartialEq, Eq)]
enum Fruit {
    Apple,
    Banana,
    Mango,
    Lychee,
    Pineapple,
}

fn fruit_basket(basket: &mut HashMap<Fruit, u32>) {
    let fruit_kinds = vec![
        Fruit::Apple,
        Fruit::Banana,
        Fruit::Mango,
        Fruit::Lychee,
        Fruit::Pineapple,
    ];

    for fruit in fruit_kinds {
        basket.entry(fruit).or_insert(1);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_fruit_basket() -> HashMap<Fruit, u32> {
        let mut basket = HashMap::<Fruit, u32>::new();
        basket.insert(Fruit::Apple, 4);
        basket.insert(Fruit::Mango, 2);
        basket.insert(Fruit::Lychee, 5);

        basket
    }

    #[test]
    fn test_given_fruits_are_not_modified() {
        let mut basket = get_fruit_basket();
        fruit_basket(&mut basket);
        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);
        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);
        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);
    }

    #[test]
    fn at_least_five_types_of_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&mut basket);
        let count_fruit_kinds = basket.len();
        assert!(count_fruit_kinds >= 5);
    }

    #[test]
    fn greater_than_eleven_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&mut basket);
        let count = basket.values().sum::<u32>();
        assert!(count > 11);
    }
}
```

### hashmaps3.rs

ãƒãƒ¼ãƒ ãŒã™ã§ã« `scores` ã«å­˜åœ¨ã—ã¦ã„ãŸå ´åˆã®ç‚¹æ•°ã®æ›´æ–°ã®ã¨ã“ã‚ã§ã€ `t.name.clone()` ã¨ã—ãŸã®ãŒæ­£ã—ã„ã‹ã‚ˆãã‚ã‹ã‚‰ãªã„

```rust
use std::collections::HashMap;

// A structure to store team name and its goal details.
struct Team {
    name: String,
    goals_scored: u8,
    goals_conceded: u8,
}

fn build_scores_table(results: String) -> HashMap<String, Team> {
    // The name of the team is the key and its associated struct is the value.
    let mut scores: HashMap<String, Team> = HashMap::new();

    for r in results.lines() {
        let v: Vec<&str> = r.split(',').collect();
        let team_1_name = v[0].to_string();
        let team_1_score: u8 = v[2].parse().unwrap();
        let team_2_name = v[1].to_string();
        let team_2_score: u8 = v[3].parse().unwrap();

        match scores.get(&team_1_name) {
            None => scores.insert(
                String::from(&team_1_name),
                Team {
                    name: String::from(&team_1_name),
                    goals_scored: team_1_score,
                    goals_conceded: team_2_score,
                },
            ),
            Some(t) => scores.insert(
                t.name.clone(),
                Team {
                    name: t.name.clone(),
                    goals_scored: t.goals_scored + team_1_score,
                    goals_conceded: t.goals_conceded + team_2_score,
                },
            ),
        };

        match scores.get(&team_2_name) {
            None => scores.insert(
                String::from(&team_2_name),
                Team {
                    name: String::from(&team_2_name),
                    goals_scored: team_2_score,
                    goals_conceded: team_1_score,
                },
            ),
            Some(t) => scores.insert(
                t.name.clone(),
                Team {
                    name: t.name.clone(),
                    goals_scored: t.goals_scored + team_2_score,
                    goals_conceded: t.goals_conceded + team_1_score,
                },
            ),
        };
    }
    scores
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_results() -> String {
        let results = "".to_string()
            + "England,France,4,2\n"
            + "France,Italy,3,1\n"
            + "Poland,Spain,2,0\n"
            + "Germany,England,2,1\n";
        results
    }

    #[test]
    fn build_scores() {
        let scores = build_scores_table(get_results());

        let mut keys: Vec<&String> = scores.keys().collect();
        keys.sort();
        assert_eq!(
            keys,
            vec!["England", "France", "Germany", "Italy", "Poland", "Spain"]
        );
    }

    #[test]
    fn validate_team_score_1() {
        let scores = build_scores_table(get_results());
        let team = scores.get("England").unwrap();
        assert_eq!(team.goals_scored, 5);
        assert_eq!(team.goals_conceded, 4);
    }

    #[test]
    fn validate_team_score_2() {
        let scores = build_scores_table(get_results());
        let team = scores.get("Spain").unwrap();
        assert_eq!(team.goals_scored, 0);
        assert_eq!(team.goals_conceded, 2);
    }
}
```
