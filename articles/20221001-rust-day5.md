---
title: "Rustã®å‹‰å¼· 5æ—¥ç›®"
emoji: "ğŸ¦€"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["rust", "exercise"]
published: false
---

## The Rust Programming Language æ—¥æœ¬èªç‰ˆ ç¬¬5ç« 

æ§‹é€ ä½“ã«ã¤ã„ã¦ã€‚

### 5.1 æ§‹é€ ä½“ã‚’å®šç¾©ã—ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹

* Rustã®æ§‹é€ ä½“ã¯Goã¨ä¼¼ã¦ã„ã‚‹ã®ã§è¦šãˆã‚„ã™ã„ã€‚
  * æ§‹é€ ä½“åã¯ã‚­ãƒ£ãƒ¡ãƒ«ã‚±ãƒ¼ã‚¹
  * `ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å: å‹å,` ã§è¨˜è¿°ã—ã¦ã„ãã€‚ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã¯å°æ–‡å­—ã€‚
  * ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯ãƒ”ãƒªã‚ªãƒ‰
  * ä¸€éƒ¨ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã¿ã‚’ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã«ã™ã‚‹ã“ã¨ã¯ã§ããªã„ã€‚

```rust
struct StructName {
    field1: String,
    field2: u64,
    field3: bool,
}
```

* åˆæœŸåŒ–çœç•¥è¨˜æ³•ã‚„æ§‹é€ ä½“æ›´æ–°è¨˜æ³•ã¯ã¡ã‚‡ã£ã¨ã¯ã¾ã‚Šãã†ã ã—ã‚ã‚“ã¾ã‚Šä½¿ã„ãŸããªã„
* ã‚¿ãƒ—ãƒ«æ§‹é€ ä½“ã¯ã€Œåå‰ä»˜ãã‚¿ãƒ—ãƒ«ã€ã¿ãŸã„ãªæ„Ÿã˜ã§ä½¿ã„ã‚„ã™ãã†
  * `struct Color(i32, i32, i32)` ã¨å®£è¨€æ–¹æ³•ã‚‚å‰²ã¨ã‚ã‹ã‚Šã‚„ã™ã„
* ãªã«ã‚‚ãªã„ã‚¿ãƒ—ãƒ«ã«åå‰ã‚’ä»˜ã‘ãŸã‚‚ã®ãŒãƒ¦ãƒ‹ãƒƒãƒˆæ§˜æ§‹é€ ä½“ã¨å‘¼ã°ã‚Œã‚‹

### 5.2 æ§‹é€ ä½“ã‚’ä½¿ã£ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¾‹

`println!` ãƒã‚¯ãƒ­ã§è¡¨ç¤ºã™ã‚‹ãŸã‚ã«ã¯ `std::fmt::Display` ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ãªã„ã¨ã„ã‘ãªã„ã‘ã‚Œã©ã€ãã‚ŒãŒæº€ãŸã›ãªã„å ´åˆã«ã¯ `#[derive(Debug)]` æ³¨é‡ˆã‚’è¶³ã—ã¦ã€`println!` ãƒã‚¯ãƒ­ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—åˆ—å†…ã§ `{:?}` ã‚‚ã—ãã¯ `{:#?}` ã‚’ä½¿ã£ã¦è¡¨ç¤ºã§ãã‚‹ã€‚

### 5.3 ãƒ¡ã‚½ãƒƒãƒ‰è¨˜æ³•

* æ§‹é€ ä½“ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¦ã¦ã€ `impl æ§‹é€ ä½“å` ã®ãƒ–ãƒ­ãƒƒã‚¯ã®ä¸­ã§é–¢æ•°ã‚’å®£è¨€ã™ã‚‹ã€‚
  * ç¬¬1å¼•æ•°ã¯ `self` ã¨ã—ã¦ã€ã“ã‚ŒãŒãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ¬ã‚·ãƒ¼ãƒãƒ¼ã¨ãªã‚‹ã€‚ã‚‚ã¡ã‚ã‚“ã»ã—ã„ã‚‚ã®ã«åˆã‚ã›ã¦ `&self` ã‚„ `&mut self` ã«ã§ãã‚‹ã€‚
* æ§‹é€ ä½“ã«ã¯ `self` ã‚’å¼•æ•°ã«å–ã‚‰ãªã„é–¢é€£é–¢æ•°ã‚’ä½œã‚Œã¦ã€ã“ã‚Œã§ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ã‹ã‚’ç”¨æ„ã§ãã‚‹ã€‚å€‹äººçš„ã«ã¯Goã®æ…£ç¿’ã«é ¼ã£ãŸæ›¸ãæ–¹ã‚ˆã‚Šã¯å¥½ãã€‚ï¼ˆGoã ã¨ `NewXXX()` é–¢æ•°ã‚’ç”¨æ„ã™ã‚‹ãŒã€æ…£ç¿’ã§ã—ã‹ãªã„ï¼‰
* implãƒ–ãƒ­ãƒƒã‚¯ã¯è¤‡æ•°ã‚ã£ã¦ã‚‚ã‚ˆã„

## Rustlings

structs ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒç¬¬5ç« ã«ç›¸å½“ã™ã‚‹ã‚ˆã†ãªã®ã§ã‚„ã£ã¦ã„ãã€‚

### structs1.rs

æ§‹é€ ä½“ã¯ã¨ã¦ã‚‚ç´ ç›´ãªã®ã§ã™ã‚“ãªã‚Šã§ããŸã€‚

```rust
struct ColorClassicStruct {
    red: u32,
    green: u32,
    blue: u32,
}

struct ColorTupleStruct(u32, u32, u32);

#[derive(Debug)]
struct UnitLikeStruct();

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn classic_c_structs() {
        // TODO: Instantiate a classic c struct!
        let green = ColorClassicStruct {
            red: 0,
            green: 255,
            blue: 0,
        };

        assert_eq!(green.red, 0);
        assert_eq!(green.green, 255);
        assert_eq!(green.blue, 0);
    }

    #[test]
    fn tuple_structs() {
        // TODO: Instantiate a tuple struct!
        let green = ColorTupleStruct(0, 255, 0);

        assert_eq!(green.0, 0);
        assert_eq!(green.1, 255);
        assert_eq!(green.2, 0);
    }

    #[test]
    fn unit_structs() {
        // TODO: Instantiate a unit-like struct!
        let unit_like_struct = UnitLikeStruct();
        let message = format!("{:?}s are fun!", unit_like_struct);

        assert_eq!(message, "UnitLikeStructs are fun!");
    }
}
```

### structs2.rs

æ§‹é€ ä½“æ›´æ–°æ³•ã€ã“ã†ã„ã†å ´åˆã«ã¯ä¾¿åˆ©ãªã‚“ã ãªãƒ¼ã¨ç†è§£ã—ãŸã€‚

```rust
#[derive(Debug)]
struct Order {
    name: String,
    year: u32,
    made_by_phone: bool,
    made_by_mobile: bool,
    made_by_email: bool,
    item_number: u32,
    count: u32,
}

fn create_order_template() -> Order {
    Order {
        name: String::from("Bob"),
        year: 2019,
        made_by_phone: false,
        made_by_mobile: false,
        made_by_email: true,
        item_number: 123,
        count: 0,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn your_order() {
        let order_template = create_order_template();
        // TODO: Create your own order using the update syntax and template above!
        let your_order = Order {
            name: String::from("Hacker in Rust"),
            count: 1,
            ..order_template
        };
        assert_eq!(your_order.name, "Hacker in Rust");
        assert_eq!(your_order.year, order_template.year);
        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);
        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);
        assert_eq!(your_order.made_by_email, order_template.made_by_email);
        assert_eq!(your_order.item_number, order_template.item_number);
        assert_eq!(your_order.count, 1);
    }
}
```

### structs3.rs

æ§‹é€ ä½“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…ã¯ã€ã“ã®å•é¡Œã®ãƒ¬ãƒ™ãƒ«ã§ã¯éå¸¸ã«ç´ ç›´ã ã£ãŸã®ã§ã€é€†ã«ä½•ã‚‚ã¯ã¾ã‚‰ãªã‹ã£ãŸã€‚ã‚‚ã—ã“ã“ã§ `&mut self` ã¿ãŸã„ãªã‚‚ã®ã˜ã‚ƒãªã„ã¨ã„ã‘ãªã„å•é¡Œã ã£ãŸã‚‰ã¯ã¾ã‚‹ã‹ã‚‚çŸ¥ã‚Œãªã„ã€‚

```rust
#[derive(Debug)]
struct Package {
    sender_country: String,
    recipient_country: String,
    weight_in_grams: i32,
}

impl Package {
    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {
        if weight_in_grams <= 0 {
            panic!("Can not ship a weightless package.")
        } else {
            Package {
                sender_country,
                recipient_country,
                weight_in_grams,
            }
        }
    }

    fn is_international(&self) -> bool {
        self.sender_country != self.recipient_country
    }

    fn get_fees(&self, cents_per_gram: i32) -> i32 {
        self.weight_in_grams * cents_per_gram
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn fail_creating_weightless_package() {
        let sender_country = String::from("Spain");
        let recipient_country = String::from("Austria");

        Package::new(sender_country, recipient_country, -2210);
    }

    #[test]
    fn create_international_package() {
        let sender_country = String::from("Spain");
        let recipient_country = String::from("Russia");

        let package = Package::new(sender_country, recipient_country, 1200);

        assert!(package.is_international());
    }

    #[test]
    fn create_local_package() {
        let sender_country = String::from("Canada");
        let recipient_country = sender_country.clone();

        let package = Package::new(sender_country, recipient_country, 1200);

        assert!(!package.is_international());
    }

    #[test]
    fn calculate_transport_fees() {
        let sender_country = String::from("Spain");
        let recipient_country = String::from("Spain");

        let cents_per_gram = 3;

        let package = Package::new(sender_country, recipient_country, 1500);

        assert_eq!(package.get_fees(cents_per_gram), 4500);
    }
}
```
