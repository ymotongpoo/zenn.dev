---
title: "Rustã®å‹‰å¼· 4æ—¥ç›®"
emoji: "ğŸ¦€"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["rust", "exercise"]
published: true
---

## The Rust Programming Language æ—¥æœ¬èªç‰ˆ ç¬¬4ç« 

ã„ã‚ˆã„ã‚ˆRustã®ç‰¹å¾´çš„ãªæ©Ÿèƒ½ã§ã‚ã‚‹ã€Œæ‰€æœ‰æ¨©ã€ã«ã¤ã„ã¦ã€‚

### 4.1 æ‰€æœ‰æ¨©ã¨ã¯

* ãƒ’ãƒ¼ãƒ—ã«ç©ã¾ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã®æ•´ç†ã¯ã™ã¹ã¦æ‰€æœ‰æ¨©ãŒè§£æ±ºã™ã‚‹å•é¡Œã§ã‚ã‚‹ã€ã¨ã„ã†ä¸»æ—¨ã®ã‚«ãƒ©ãƒ ã¯ãªã‚“ã¨ãªãã‚ã‹ã£ãŸã€‚
* æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã¯ã‚µã‚¤ã‚ºå›ºå®šã§ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã ã‹ã‚‰ä¸ä¾¿ãªã®ã§ã€`String` å‹ã‚’ä½¿ã†ã€‚ã“ã‚Œã¯ãƒ’ãƒ¼ãƒ—ã«ç©ã¾ã‚Œã‚‹ã€‚
* Rustã¯GCã‚„æ‰‹å‹•ã§ã® `allocate` / `free` ã®ä»£ã‚ã‚Šã«ã€ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹ã¨ãã«æš—é»™çš„ã« `drop` ã¨ã„ã†ç‰¹åˆ¥ãªé–¢æ•°ã‚’å‘¼ã‚“ã§ã€ä¸å¿…è¦ã«ãªã£ãŸãƒ¡ãƒ¢ãƒªã‚’è¿”å´ã™ã‚‹ã€‚
* `String` å‹ã®ã‚ˆã†ã«ãƒ’ãƒ¼ãƒ—ã«ä¿æŒã™ã‚‹å€¤ãŒã‚ã‚‹å¤‰æ•°ã‚’ã‚³ãƒ”ãƒ¼ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€åˆ¥ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãŒä½œã‚‰ã‚Œã‚‹ã ã‘ï¼ˆshallow copyï¼‰ã§ãƒ’ãƒ¼ãƒ—é ˜åŸŸã«ã‚ã‚‹ãƒ‡ãƒ¼ã‚¿ã¯å…±é€šã¨ãªã‚‹ã€‚
  * ã“ã®çŠ¶æ…‹ã®ã¾ã¾ã ã¨ `drop` ã—ãŸã¨ãã«éå‰°ã«ãƒ¡ãƒ¢ãƒªã‚’é–‹æ”¾ã™ã‚‹ã“ã¨ã«ãªã‚‹ã®ã§ã€Rustã§ã¯ã‚³ãƒ”ãƒ¼å…ƒã®æ–¹ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒç„¡åŠ¹åŒ–ã—ã¦å‘¼ã³å‡ºã›ãªã„ã‚ˆã†ã«ã™ã‚‹ã€‚ï¼ˆã€Œãƒ ãƒ¼ãƒ–ã—ãŸã€ã¨è¦‹åšã™ï¼‰

```rust
{
    let s1 = String::from("hello");
    let s2 = s1; // ã“ã“ã§ s1 ã¯ãƒ ãƒ¼ãƒ–ã•ã‚ŒãŸã¨è¦‹åšã•ã‚Œã‚‹
}
```

ã‚‚ã—ã€shallow copyã§ã¯ãªãdeep copyã—ãŸã‹ã£ãŸã‚‰ã€æ¬¡ã®ã‚ˆã†ã« `clone` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã¶å¿…è¦ãŒã‚ã‚‹ã€‚

```rust
{
    let s1 = String::from("hello");
    let s2 = s1.clone();
}
```

`Copy` ãƒˆãƒ¬ã‚¤ãƒˆã‚’æŒã£ã¦ã„ã‚‹ç‰¹åˆ¥ãªå‹ã«é–¢ã—ã¦ã¯ã€ãƒ‡ãƒ¼ã‚¿ãŒã‚¹ã‚¿ãƒƒã‚¯ã«ç©ã¾ã‚Œã¦ã„ã‚‹ã®ã§ã€shallow copyã‚‚deep copyã‚‚é•ã„ãŒãªãã€ãƒ ãƒ¼ãƒ–ã®åˆ¤å®šãŒã•ã‚Œãªããªã‚‹ã€‚

* é–¢æ•°ã«å€¤ã‚’æ¸¡ã—ãŸå ´åˆã‚„æˆ»ã‚Šå€¤ã§ã‚‚å¤‰æ•°ã«ä»£å…¥ã—ãŸã¨ãã¨åŒæ§˜ã®ãƒ ãƒ¼ãƒ–ã‚„ã‚³ãƒ”ãƒ¼ã®åˆ¤å®šãŒã•ã‚Œã‚‹

### 4.2 å‚ç…§ã¨å€Ÿç”¨

* æ¯å›ãƒ ãƒ¼ãƒ–ã‚„ã‚³ãƒ”ãƒ¼ã‚’æ°—ã«ã—ã¦ãŸã‚‰ä¸ä¾¿ãªã®ã§ã€ `&` ã‚’ã¤ã‹ã£ã¦å‚ç…§ã‚’æ¸¡ã›ã‚‹
  * å‚ç…§ã‚’è²°ã†ã“ã¨ã‚’ã€Œå€Ÿç”¨ã€ã¨å‘¼ã¶ã€‚
* å‚ç…§ã‚‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã®ã§ã€å€Ÿç”¨ã—ãŸä¸Šã§å€¤ã‚’å¤‰æ›´ã—ã‚ˆã†ã¨æ€ã£ãŸã‚‰ `&mut` ã§ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªå‚ç…§ã«ã—ãªã„ã¨ã„ã‘ãªã„ã€‚
  * `&mut` ã¯1ã¤ã®ã‚¹ã‚³ãƒ¼ãƒ—ã§1å€‹ã—ã‹å­˜åœ¨ã—ã¦ã¯ã„ã‘ãªã„
  * `&` ã§å€Ÿç”¨ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã¯ `&mut` ã§å€Ÿç”¨ã§ããªã„
* ãƒ€ãƒ³ã‚°ãƒªãƒ³ã‚°ã‚‚é˜²ã„ã§ãã‚Œã‚‹ã®ã§ã€ç”Ÿæˆã•ã‚ŒãŸå¤‰æ•°ãŒ `drop` ã•ã‚Œã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã¨å‚ç…§ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’ã‚ˆãè€ƒãˆã‚‹å¿…è¦ãŒã‚ã‚‹

### 4.3 ã‚¹ãƒ©ã‚¤ã‚¹å‹

* ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®ä¸­èº«ã®è¦ç´ ã®ä¸€éƒ¨ã‚’å‚ç…§ã™ã‚‹ãŸã‚ã®å‹

## Rustlings

### primitive_types3.rs

`a.len()` ã§ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®é•·ã•ã‚’è¦‹ã¦ã„ã‚‹ifå¼ãªã®ã§ã€ `a` ã‚’é©å½“ã«ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«ã—ãŸã€‚

```rust
fn main() {
    let a = 1..100;

    if a.len() >= 100 {
        println!("Wow, that's a big array!");
    } else {
        println!("Meh, I eat arrays like that for breakfast.");
    }
}
```

### primitive_types4.rs

é…åˆ—ã‹ã‚‰ã‚¹ãƒ©ã‚¤ã‚¹ã‚’å–ã‚Œã¨ã„ã†ã“ã¨ã ã£ãŸã®ã§ã€ `assert_eq` ã®ä¸­èº«ã‚’è¦‹ã¦ã€è©²å½“ã™ã‚‹è¦ç´ ã‚’æŠœãå‡ºã™ã‚¹ãƒ©ã‚¤ã‚¹ã‚’æ›¸ã„ãŸã€‚

```rust
#[test]
fn slice_out_of_array() {
    let a = [1, 2, 3, 4, 5];

    let nice_slice = &a[1..4];

    assert_eq!([2, 3, 4], nice_slice)
}
```

### primitive_types5.rs

ä¸‹ã® `println!` ãƒã‚¯ãƒ­ã§ `name` ã¨ `age` ã¨ã„ã†å¤‰æ•°ãŒãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ã«å…¥ã‚Œã‚‰ã‚Œã¦ãŸã®ã§ã€ `cat` ã‚’å±•é–‹ã—ã¦å—ã‘å–ã£ãŸã€‚

```rust
fn main() {
    let cat = ("Furry McFurson", 3.5);
    let (name, age) = cat;

    println!("{} is {} years old.", name, age);
}
```

### primitive_types6.rs

ã‚¿ãƒ—ãƒ«ã®è¦ç´ ã¯ãƒ”ãƒªã‚ªãƒ‰ã¨æ·»å­—ã§ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã®ã§ãã‚Œã‚’æ›¸ã„ãŸ

```rust
#[test]
fn indexing_tuple() {
    let numbers = (1, 2, 3);
    // Replace below ??? with the tuple indexing syntax.
    let second = numbers.1;

    assert_eq!(2, second, "This is not the 2nd number in the tuple!")
}
```

### move_semantics1.rs

`vec1.push(88)` ã¯å¯å¤‰ãªæ“ä½œãªã®ã§ã€ `vec1` ã‚’å®£è¨€ã™ã‚‹ã¨ãã«ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã§å®£è¨€ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´ã€‚

```rust
fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);

    vec1.push(88);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);
}

fn fill_vec(vec: Vec<i32>) -> Vec<i32> {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
```

### move_semantics2.rs

`vec0` ã¯ `fill_vec` ã«æ¸¡ã•ã‚ŒãŸã¨ã“ã‚ã§ãƒ ãƒ¼ãƒ–ã•ã‚Œã¦ã‚‹ã®ã§ã€ `vec0.len()` ã¨ã—ã¦è§¦ã‚Œãªã„ã€‚ãƒ ãƒ¼ãƒ–ã§ã¯ãªãã‚³ãƒ”ãƒ¼ã¨ã—ã¦ `fill_vec` ã«æ¸¡ã›ã°ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒé€šã‚‹ã€‚

```rust
fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0.clone());

    // Do not change the following line!
    println!("{} has length {} content `{:?}`", "vec0", vec0.len(), vec0);

    vec1.push(88);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);
}

fn fill_vec(vec: Vec<i32>) -> Vec<i32> {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
```

### move_semantics3.rs

`fill_vec` ã®ä»®å¼•æ•°ã® `vec` ã¯ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã®ã§ã€ãã®ã¾ã¾å®Ÿè¡Œã—ã¦ã—ã¾ã†ã¨ `vec.push(22);` ã®è¡Œã§ã‚¨ãƒ©ãƒ¼ãŒå‡ºã¦ã—ã¾ã†ã€‚ãªã®ã§ã‚·ãƒ£ãƒ‰ãƒ¼ã‚¤ãƒ³ã‚°ã‚’ã—ã¦ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã«ã—ãŸã€‚ï¼ˆã“ã‚Œã¾ã§ã®å•é¡Œã®ã‚µãƒ³ãƒ—ãƒ«ã¨åŒã˜æ–¹æ³•ï¼‰

```rust
fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);

    vec1.push(88);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);
}

fn fill_vec(vec: Vec<i32>) -> Vec<i32> {
    let mut vec = vec;
    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
```

ä»–ã®æ–¹æ³•ã¨ã—ã¦ã€ `fill_vec` ã®ä»®å¼•æ•°ã® `vec` ã‚’ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªå‹ã¨ã—ã¦å®£è¨€ã—ãŸã€‚

```rust
fn main() {
    let mut vec0 = Vec::new();

    let mut vec1 = fill_vec(&mut vec0);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);

    vec1.push(88);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);
}

fn fill_vec(vec: &mut Vec<i32>) -> Vec<i32> {
    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec.to_vec()
}
```

### move_semantics4.rs

`fill_vec` ã®ã‚³ãƒ¡ãƒ³ãƒˆã«ã€Œã‚‚ã†å¼•æ•°ã‚’å–ã‚‰ãªã„ã€ã¨æ›¸ã„ã¦ã‚ã‚‹ã®ã§ã€ `vec0` ãŒå‡ºã¦ãã‚‹è¡Œã¯å…¨éƒ¨æ¶ˆã—ãŸã€‚ãã†ã™ã‚‹ã¨ã€`fill_vec` å†…ã§æ“ä½œã—ã¦ã„ã‚‹ `vec` ã®æ­£ä½“ãŒä¸æ˜ãªã®ã§ã€æ–°ã—ã„ `Vec` å‹ã®å€¤ã‚’ç”Ÿæˆã—ãŸã€‚æˆ»ã‚Šå€¤ã¯ `vec1` ã«ãƒ ãƒ¼ãƒ–ã•ã‚Œã¦ã„ã¦ã€ãã®å¾Œã®æ“ä½œã¯ç‰¹ã«å•é¡ŒãŒãªã„ã®ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒé€šã£ãŸã€‚

```rust
fn main() {
    let mut vec1 = fill_vec();

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);

    vec1.push(88);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);
}

// `fill_vec()` no longer takes `vec: Vec<i32>` as argument
fn fill_vec() -> Vec<i32> {
    let mut vec = Vec::new();

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
```

### move_semantics5.rs

`y` ã¨ `z` ã® `&mut` ã®å®£è¨€ãŒç«‹ã¦ç¶šã‘ã«ä¸¦ã‚“ã§ã„ã‚‹ã›ã„ã§ä¸€åº¦ã«2ã¤ä»¥ä¸Šã®å€Ÿç”¨ãŒèµ·ãã¦ã„ã‚‹ã®ã§ã€ `let z = &mut x;` ã¨ `*y += 100;` ã‚’å…¥ã‚Œæ›¿ãˆã¦ã€å‚ç…§ãŒåŒæ™‚ã«èµ·ããªã„ã‚ˆã†ã«ã—ãŸã‚‰ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒé€šã£ãŸã€‚

```rust
fn main() {
    let mut x = 100;
    let y = &mut x;
    *y += 100;
    let z = &mut x;
    *z += 1000;
    assert_eq!(x, 1200);
}
```

ã—ã‹ã—ãªã‚“ã§ã“ã‚Œã¯æ¬¡ã®ã‚ˆã†ã«ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŒ‡å®šã—ãªãã¦ã‚‚è‰¯ã„ã‚“ã ã‚ã†ã‹ã€‚

```rust
fn main() {
    let mut x = 100;
    {
        let y = &mut x;
        *y += 100;
    }
    {
        let z = &mut x;
        *z += 1000;
    }
    assert_eq!(x, 1200);
}
```

ï¼ˆè£œè¶³: @lambda_sakura ã•ã‚“ã‹ã‚‰ã€ã“ã‚Œã¯ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã®å•é¡Œã‚‚å…¥ã£ã¦ã‚‹ã¨è¨€ã‚ã‚Œã¦ã€ã¾ã èª­ã‚“ã§ãªã„ç« ã®çŸ¥è­˜ã‚‚å¿…è¦ã ã£ãŸã¨ç†è§£ã—ãŸã€‚ï¼‰

### move_semantics6.rs

ã¾ãš `get_char` ãŒå¿…è¦ã‚‚ãªãæ‰€æœ‰æ¨©ã‚’å–å¾—ã—ã¦ã„ãŸã®ã§ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªå€Ÿç”¨ã‚’ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´ã—ãŸã€‚ã“ã‚Œã§ `string_uppercase` ã§ã‚‚ `data` ãŒæ¸¡ã›ã‚‹ã‚ˆã†ã«ãªã£ãŸã€‚
ã—ã‹ã—æœ€åˆã®è¡Œã® `data = &data.to_uppercase();` ã§ã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹ã€‚

```console
19 | fn string_uppercase(mut data: &String) {
   |                               - let's call the lifetime of this reference `'1`
20 |     data = &data.to_uppercase();
   |     --------^^^^^^^^^^^^^^^^^^^- temporary value is freed at the end of this statement
   |     |       |
   |     |       creates a temporary which is freed while still in use
   |     assignment requires that borrow lasts for `'1`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0716`.
```

`&data.to_uppercase()` ãŒä¸€æ™‚çš„ãªå€¤ã‚’ç”Ÿæˆã—ã—ã¦ã€ãã‚Œã‚’ `data` ã«æ¸¡ã—ã¦ã„ã‚‹ã‘ã‚Œã©ã‚‚ã€å³æ¶ˆãˆã‚‹ã‹ã‚‰å±ãªã„ã£ã¦ã“ã¨ã‚‰ã—ã„ã‚“ã§ã€ã¨ã‚Šã‚ãˆãšã“ã®é–¢æ•°ã®ç”¨é€”ã§ã‚ã‚Œã° `data` ã‚’ã‚·ãƒ£ãƒ‰ãƒ¼ã‚¤ãƒ³ã‚°ã—ã¨ã‘ã°è‰¯ã•ãã†ã€‚ã§ã€ã‚„ã£ã¦ã¿ãŸã‚‰ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«é€šã£ãŸã€‚

```rust
fn main() {
    let data = "Rust is great!".to_string();

    get_char(&data);

    string_uppercase(&data);
}

// Should not take ownership
fn get_char(data: &String) -> char {
    data.chars().last().unwrap()
}

// Should take ownership
fn string_uppercase(mut data: &String) {
    let data = &data.to_uppercase();

    println!("{}", data);
}
```

ä»Šæ—¥ã¯ã“ã“ã¾ã§ã€‚
