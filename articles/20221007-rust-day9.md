---
title: "Rust„ÅÆÂãâÂº∑ 9Êó•ÁõÆ"
emoji: "ü¶Ä"
type: "tech" # tech: ÊäÄË°ìË®ò‰∫ã / idea: „Ç¢„Ç§„Éá„Ç¢
topics: ["rust", "exercise"]
published: true
---

## The Rust Programming Language Êó•Êú¨Ë™ûÁâà Á¨¨9Á´†

„Ç®„É©„ÉºÂá¶ÁêÜ„ÅÆË©±„ÄÇGo„Å®ÂêåÊßò„Å´ÂõûÂæ©ÂèØËÉΩ„Ç®„É©„Éº„Å®ÂõûÂæ©‰∏çËÉΩ„Ç®„É©„Éº„Åå„ÅÇ„Çã„ÄÇ

### 9.1 panic!„ÅßÂõûÂæ©‰∏çËÉΩ„Å™„Ç®„É©„Éº

* `panic!` „Éû„ÇØ„É≠„ÇíÂëº„Å∂„Å®„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„ÅßÂëº„Å∞„Çå„ÅüÁÆáÊâÄ„ÇíÊåáÊëò„Åó„Å¶Â∑ª„ÅçÊàª„Çã
* `Cargo.toml` „Åß `[profile.release]` „ÅÆ `panic = 'abort'` „ÇíÊåáÂÆö„Åô„Çã„Å®„ÄÅÂ∑ª„ÅçÊàª„Åó„Åã„ÇâÁï∞Â∏∏ÁµÇ‰∫Ü„Å´„Å™„Çã
* `RUST_BACKTRACE=1` „Å®„Åô„Çã„Å®„Éê„ÉÉ„ÇØ„Éà„É¨„Éº„Çπ„ÅåÂèñ„Çå„Çã

### 9.2 Result„ÅßÂõûÂæ©ÂèØËÉΩ„Å™„Ç®„É©„Éº

* ResultÂûã„Å®„ÅÑ„ÅÜÂàóÊåôÂûã„Çí‰Ωø„Å£„Å¶„Ç®„É©„ÉºÂá¶ÁêÜ„Çí„Åô„Çã„ÅÆ„ÅåÊÖ£‰æã
  * Go„Å†„Å£„Åü„Çâ `t, err` „ÅÆ„Çø„Éó„É´„ÅßÂèó„ÅëÂèñ„Å£„Å¶„ÅÑ„Çã„ÅÆ„ÇíResultÂûã„Åß„ÇÑ„Å£„Å¶„ÅÑ„Çã
* „Éû„ÉÉ„ÉÅ„Ç¨„Éº„Éâ„Çí‰Ωø„ÅÜ„Å®„Åç„Å´„Ç¨„Éº„ÉâÊù°‰ª∂Âºè„Å´„É†„Éº„Éñ„Åï„Çå„Å¶„Åª„Åó„Åè„Å™„ÅÑÂ†¥Âêà„Å´„ÅØ `ref` „Ç≠„Éº„ÉØ„Éº„Éâ„Çí‰Ωø„ÅÜ
* `unwrap` „Å® `expect` „Çí‰Ωø„ÅÜ„Å®„ÄÅ„Ç®„É©„Éº„ÅÆÂá¶ÁêÜ„ÇíÁúÅÁï•„Åó„Å¶„ÄÅ„Ç®„É©„Éº„Å†„Å£„ÅüÂ†¥Âêà„Å´„ÅØ„Éë„Éã„ÉÉ„ÇØ„Åô„Çã„Çà„ÅÜ„Å´„Åó„Å¶„Åè„Çå„Çã
  * `expect` „ÅÆÂ†¥Âêà„ÅØ„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅåÈÅ∏„Åπ„Çã
* „Ç®„É©„Éº„ÇíÁßªË≠≤„Åó„Åü„Åã„Å£„Åü„Çâ„Åù„ÅÆ„Åæ„Åæ„Ç®„É©„Éº„ÇíËøî„Åó„Åü„Çâ„ÅÑ„ÅÑ

```rust
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -> Result<String, io::Error> {
    let f = File::open("hello.txt");

    let mut f = match f {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),
    }
}
```

* `?` ÊºîÁÆóÂ≠ê„Çí‰Ωø„ÅÜ„Å®„Ç®„É©„Éº„ÅØ„Åù„ÅÆ„Åæ„Åæ„É™„Çø„Éº„É≥„Åó„Å¶„Åè„Çå„Çã
  * „Åü„Å†„Åó `?` „ÅØ `Result` „ÇíËøî„ÅôÈñ¢Êï∞„Åß„Åó„Åã‰Ωø„Åà„Å™„ÅÑ

```rust
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut s = String::new();

    File::open("hello.txt")?.read_to_string(&mut s)?;

    Ok(s)
}
```

### 9.3 panic!„Åô„Åπ„Åç„Åã„Åô„Çã„Åæ„ÅÑ„Åã

* „Å†„ÅÑ„Åü„ÅÑ `Result` „ÇíËøî„Åó„Åü„Åª„ÅÜ„Åå„ÅÑ„ÅÑ

## Rustlings

### errors1.rs

„ÉÜ„Çπ„Éà„Åß„ÅØ `Result` „ÇíÊâ±„ÅÜ„Çà„ÅÜ„Å´Êõ∏„Åã„Çå„Å¶„ÅÑ„Åü„Çì„Åß `generate_nametag_text` „ÅÆÊàª„ÇäÂÄ§„ÇíÂ§âÊõ¥

```rust
pub fn generate_nametag_text(name: String) -> Result<String, String> {
    if name.is_empty() {
        Err(String::from("`name` was empty; it must be nonempty."))
    } else {
        Ok(format!("Hi! My name is {}", name))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generates_nametag_text_for_a_nonempty_name() {
        assert_eq!(
            generate_nametag_text("Beyonc√©".into()),
            Ok("Hi! My name is Beyonc√©".into())
        );
    }

    #[test]
    fn explains_why_generating_nametag_text_fails() {
        assert_eq!(
            generate_nametag_text("".into()),
            // Don't change this line
            Err("`name` was empty; it must be nonempty.".into())
        );
    }
}
```

### errors2.rs

`item_quantity.parse::<i32>()` „Åå `Result` „ÇíËøî„Åô„ÅÆ„Åß„ÄÅ„Åù„ÅÆ‰∏ã„ÅÆ `Ok` „ÅÆÂûã„ÅåÂêà„Çè„Å™„ÅÑ„ÄÇ„Å™„ÅÆ„Åß„ÄÅ`Err` „Å†„Å£„ÅüÂ†¥Âêà„Å´„ÅØ„Åù„ÅÆ„Åæ„Åæ„Ç®„É©„Éº„ÇíËøî„Åô„Çà„ÅÜ„Å´ `?` „ÇíËøΩÂä†„Åó„Åü„Çâ„ÉÜ„Çπ„Éà„ÅåÈÄö„Å£„Åü„ÄÇ

```rust
use std::num::ParseIntError;

pub fn total_cost(item_quantity: &str) -> Result<i32, ParseIntError> {
    let processing_fee = 1;
    let cost_per_item = 5;
    let qty = item_quantity.parse::<i32>()?;

    Ok(qty * cost_per_item + processing_fee)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn item_quantity_is_a_valid_number() {
        assert_eq!(total_cost("34"), Ok(171));
    }

    #[test]
    fn item_quantity_is_an_invalid_number() {
        assert_eq!(
            total_cost("beep boop").unwrap_err().to_string(),
            "invalid digit found in string"
        );
    }
}
```

### errors3.rs

`main` „ÅØ `()` „ÇíËøî„ÅôÈñ¢Êï∞„Å™„ÅÆ„Åß„ÄÅ‰∏≠„Åß `?` „ÅØ‰Ωø„Åà„Å™„ÅÑ„ÄÇ„Å™„ÅÆ„Åß `match` „Çí‰Ωø„Å£„Å¶„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„Åó„Åü„ÄÇ

```rust
use std::num::ParseIntError;

fn main() {
    let mut tokens = 100;
    let pretend_user_input = "8";

    let cost = total_cost(pretend_user_input);
    let cost = match cost {
        Ok(c) => c,
        Err(e) => panic!("Unexpected input: {}", e),
    };

    if cost > tokens {
        println!("You can't afford that many!");
    } else {
        tokens -= cost;
        println!("You now have {} tokens.", tokens);
    }
}

pub fn total_cost(item_quantity: &str) -> Result<i32, ParseIntError> {
    let processing_fee = 1;
    let cost_per_item = 5;
    let qty = item_quantity.parse::<i32>()?;

    Ok(qty * cost_per_item + processing_fee)
}
```

### errors4.rs

`value` „ÅåÈùûÊ≠£ÂÄ§„ÅÆ„Å®„Åç„ÅÆÂá¶ÁêÜ„Åå„Å™„Åã„Å£„Åü„ÅÆ„ÅßËøΩÂä†

```rust
#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {
        if value > 0 {
            Ok(PositiveNonzeroInteger(value as u64))
        } else if value == 0 {
            Err(CreationError::Zero)
        } else {
            Err(CreationError::Negative)
        }
    }
}

#[test]
fn test_creation() {
    assert!(PositiveNonzeroInteger::new(10).is_ok());
    assert_eq!(
        Err(CreationError::Negative),
        PositiveNonzeroInteger::new(-10)
    );
    assert_eq!(Err(CreationError::Zero), PositiveNonzeroInteger::new(0));
}
```

### errors5.rs

„Äå„Åæ„Å†Êïô„Åà„Å¶„Å™„ÅÑBox„Å®Trait„ÅåÂá∫„Å¶„Åè„Çã„Åë„Å©„ÄÅÂàÜ„Åã„Çã„Å®ÊÄù„ÅÜ„Çà„Éº„Äç„Å£„Å¶Êõ∏„ÅÑ„Å¶„ÅÇ„Å£„Åü„Åë„Å©„ÄÅ„Çè„Åã„Çâ„Å™„ÅÑ„Çì„ÅßÂÖà„Å´„Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆÊñπ„ÉÅ„É©Ë¶ã„Åó„Å¶„Åä„Åè„ÄÇ
12Á´†„ÅÆ„ÅÇ„Åü„Çä„Å´„Éà„É¨„Ç§„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíËøî„Åó„Å¶„Ç®„É©„ÉºÂûã„Çí„Åæ„Å®„ÇÅ„Å¶Ëøî„Åõ„Çã„Çà„ÅÜ„Å´„Åô„Çã„Åø„Åü„ÅÑ„Å™Ë™¨Êòé„Åå„ÅÇ„Å£„Åü„Çì„Å†„Åë„Çå„Å©„ÇÇ„ÄÅÈõ∞Âõ≤Ê∞ó„Åß„Åó„Åã„Çè„Åã„Å£„Å¶„Å™„ÅÑ„ÄÇ„Åü„Å†„Åì„Çå„Åß„ÉÜ„Çπ„Éà„ÅØÈÄö„Å£„Åü„ÄÇ

„Åì„Åì„Åß `use std::num::ParseIntError` „ÅåÊòé„Å´‰Ωø„Çè„Çå„Å¶„Å™„ÅÑ„ÅÆ„Å´ÂøÖË¶Å„Å´„Å™„Å£„Å¶„Çã„ÅÆ„ÅØ `?` „ÅÆ‰∏≠„ÅßÊöó„Å´‰Ωø„Çè„Çå„Å¶„ÅÑ„Çã„Åã„Çâ„Å†„Çç„ÅÜ„Åã

```rust
use std::error;
use std::fmt;
use std::num::ParseIntError;

// TODO: update the return type of `main()` to make this compile.
fn main() -> Result<(), Box<dyn error::Error>> {
    let pretend_user_input = "42";
    let x: i64 = pretend_user_input.parse()?;
    println!("output={:?}", PositiveNonzeroInteger::new(x)?);
    Ok(())
}

// Don't change anything below this line.

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {
        match value {
            x if x < 0 => Err(CreationError::Negative),
            x if x == 0 => Err(CreationError::Zero),
            x => Ok(PositiveNonzeroInteger(x as u64)),
        }
    }
}

// This is required so that `CreationError` can implement `error::Error`.
impl fmt::Display for CreationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let description = match *self {
            CreationError::Negative => "number is negative",
            CreationError::Zero => "number is zero",
        };
        f.write_str(description)
    }
}
```

### errors6.rs

`unwrap` „ÅßÊ≠£„Åó„Åè„Ç®„É©„Éº„ÇíËøî„Åó„Å¶„ÅÑ„Å™„Åã„Å£„Åü„ÅÆ„Çí„ÄÅÂûã„ÇíÂêà„Çè„Åõ„Çã„Çà„ÅÜ„Å´„Åó„Åü

```rust
use std::num::ParseIntError;

// This is a custom error type that we will be using in `parse_pos_nonzero()`.
#[derive(PartialEq, Debug)]
enum ParsePosNonzeroError {
    Creation(CreationError),
    ParseInt(ParseIntError),
}

impl ParsePosNonzeroError {
    fn from_creation(err: CreationError) -> ParsePosNonzeroError {
        ParsePosNonzeroError::Creation(err)
    }

    fn from_parseint(err: ParseIntError) -> ParsePosNonzeroError {
        ParsePosNonzeroError::ParseInt(err)
    }
}

fn parse_pos_nonzero(s: &str) -> Result<PositiveNonzeroInteger, ParsePosNonzeroError> {
    let x = s.parse();
    match x {
        Err(e) => Err(ParsePosNonzeroError::from_parseint(e)),
        Ok(i) => PositiveNonzeroInteger::new(i).map_err(ParsePosNonzeroError::from_creation),
    }
}

// Don't change anything below this line.

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {
        match value {
            x if x < 0 => Err(CreationError::Negative),
            x if x == 0 => Err(CreationError::Zero),
            x => Ok(PositiveNonzeroInteger(x as u64)),
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_parse_error() {
        // We can't construct a ParseIntError, so we have to pattern match.
        assert!(matches!(
            parse_pos_nonzero("not a number"),
            Err(ParsePosNonzeroError::ParseInt(_))
        ));
    }

    #[test]
    fn test_negative() {
        assert_eq!(
            parse_pos_nonzero("-555"),
            Err(ParsePosNonzeroError::Creation(CreationError::Negative))
        );
    }

    #[test]
    fn test_zero() {
        assert_eq!(
            parse_pos_nonzero("0"),
            Err(ParsePosNonzeroError::Creation(CreationError::Zero))
        );
    }

    #[test]
    fn test_positive() {
        let x = PositiveNonzeroInteger::new(42);
        assert!(x.is_ok());
        assert_eq!(parse_pos_nonzero("42"), Ok(x.unwrap()));
    }
}
```
